#!/usr/bin/env python3
"""Generate synthetic blackbox CSV fixtures for testing.

Creates realistic-looking decoded blackbox CSV data that can be parsed by
parse_csv_log() and fed through the full analysis pipeline.

Run this once to regenerate fixture files:
    python3 tests/generate_fixtures.py
"""
import csv
import math
import os
import random

FIXTURES_DIR = os.path.join(os.path.dirname(__file__), "fixtures")

# Standard decoded blackbox CSV headers (INAV format)
HEADERS = [
    "loopIteration", "time (us)",
    "axisP[0]", "axisP[1]", "axisP[2]",
    "axisI[0]", "axisI[1]", "axisI[2]",
    "axisD[0]", "axisD[1]", "axisD[2]",
    "setpoint[0]", "setpoint[1]", "setpoint[2]",
    "gyroADC[0]", "gyroADC[1]", "gyroADC[2]",
    "motor[0]", "motor[1]", "motor[2]", "motor[3]",
    "rcCommand[3]",
]


def generate_flight_csv(filepath, n_frames=4000, sample_rate_hz=500,
                        noise_freqs=None, noise_amps=None,
                        overshoot_pct=0.0, tracking_delay_ms=0.0,
                        motor_spread=0.0, comment_lines=None):
    """Generate a synthetic decoded blackbox CSV file.

    Args:
        filepath: Output file path
        n_frames: Number of data frames
        sample_rate_hz: Simulated sample rate
        noise_freqs: List of noise frequencies to inject (Hz)
        noise_amps: List of noise amplitudes (°/s peak)
        overshoot_pct: Simulated step response overshoot
        tracking_delay_ms: Simulated tracking delay
        motor_spread: Motor imbalance (0-1, fraction of range)
        comment_lines: Extra header comment lines
    """
    dt_us = int(1e6 / sample_rate_hz)
    noise_freqs = noise_freqs or []
    noise_amps = noise_amps or [10.0] * len(noise_freqs)

    with open(filepath, "w", newline="") as f:
        # Write header comments (like blackbox_decode output)
        f.write("# Synthetic test data generated by generate_fixtures.py\n")
        if comment_lines:
            for line in comment_lines:
                f.write(f"# {line}\n")

        writer = csv.writer(f)
        writer.writerow(HEADERS)

        random.seed(42)  # Reproducible

        # Simulate some stick maneuvers
        # Phase 1: hover (0-25%), Phase 2: roll maneuver (25-50%),
        # Phase 3: pitch maneuver (50-75%), Phase 4: hover (75-100%)
        for i in range(n_frames):
            t_us = i * dt_us
            t_s = t_us / 1e6
            phase = i / n_frames

            # Setpoints: stick commands
            sp_roll = sp_pitch = sp_yaw = 0.0
            if 0.25 <= phase < 0.30:
                # Ramp into roll
                sp_roll = 200.0 * min(1.0, (phase - 0.25) / 0.02)
            elif 0.30 <= phase < 0.40:
                sp_roll = 200.0
            elif 0.40 <= phase < 0.45:
                sp_roll = 200.0 * max(0.0, 1.0 - (phase - 0.40) / 0.02)
            if 0.55 <= phase < 0.60:
                sp_pitch = -150.0 * min(1.0, (phase - 0.55) / 0.02)
            elif 0.60 <= phase < 0.70:
                sp_pitch = -150.0
            elif 0.70 <= phase < 0.75:
                sp_pitch = -150.0 * max(0.0, 1.0 - (phase - 0.70) / 0.02)

            # Gyro: tracks setpoint with optional delay and overshoot
            delay_samples = int(tracking_delay_ms * sample_rate_hz / 1000)
            delayed_idx = max(0, i - delay_samples)
            delayed_phase = delayed_idx / n_frames

            # Simplified tracking: gyro follows setpoint with delay
            gy_roll = sp_roll  # Will be overwritten with delayed version below
            gy_pitch = sp_pitch
            gy_yaw = sp_yaw

            # Add tracking delay effect (simplified)
            if delay_samples > 0 and i >= delay_samples:
                # Re-compute what setpoint was delay_samples ago
                dp = delayed_phase
                old_sp_roll = 0.0
                if 0.25 <= dp < 0.30:
                    old_sp_roll = 200.0 * min(1.0, (dp - 0.25) / 0.02)
                elif 0.30 <= dp < 0.40:
                    old_sp_roll = 200.0
                elif 0.40 <= dp < 0.45:
                    old_sp_roll = 200.0 * max(0.0, 1.0 - (dp - 0.40) / 0.02)
                gy_roll = old_sp_roll

                old_sp_pitch = 0.0
                if 0.55 <= dp < 0.60:
                    old_sp_pitch = -150.0 * min(1.0, (dp - 0.55) / 0.02)
                elif 0.60 <= dp < 0.70:
                    old_sp_pitch = -150.0
                elif 0.70 <= dp < 0.75:
                    old_sp_pitch = -150.0 * max(0.0, 1.0 - (dp - 0.70) / 0.02)
                gy_pitch = old_sp_pitch

            # Add overshoot at step transitions
            if overshoot_pct > 0:
                os_factor = overshoot_pct / 100.0
                # Roll step at phase 0.30
                t_after_step = phase - 0.30
                if 0 < t_after_step < 0.05:
                    gy_roll += 200.0 * os_factor * math.exp(-t_after_step * 60) * math.sin(t_after_step * 300)
                # Pitch step at phase 0.60
                t_after_step = phase - 0.60
                if 0 < t_after_step < 0.05:
                    gy_pitch += -150.0 * os_factor * math.exp(-t_after_step * 60) * math.sin(t_after_step * 300)

            # Inject noise (gyro oscillation)
            noise_roll = noise_pitch = noise_yaw = 0.0
            for freq, amp in zip(noise_freqs, noise_amps):
                noise_roll += amp * math.sin(2 * math.pi * freq * t_s + 0.0)
                noise_pitch += amp * 0.9 * math.sin(2 * math.pi * freq * t_s + 0.5)
                noise_yaw += amp * 0.4 * math.sin(2 * math.pi * freq * t_s + 1.0)

            # Add sensor noise floor
            noise_roll += random.gauss(0, 2.0)
            noise_pitch += random.gauss(0, 2.0)
            noise_yaw += random.gauss(0, 1.5)

            gy_roll += noise_roll
            gy_pitch += noise_pitch
            gy_yaw += noise_yaw

            # PID outputs (simplified)
            p_roll = sp_roll - gy_roll
            p_pitch = sp_pitch - gy_pitch
            p_yaw = sp_yaw - gy_yaw
            i_roll = p_roll * 0.1
            i_pitch = p_pitch * 0.1
            i_yaw = p_yaw * 0.05
            d_roll = -noise_roll * 0.3
            d_pitch = -noise_pitch * 0.3
            d_yaw = -noise_yaw * 0.15

            # Motors: 1000-2000 range, hover around 1500
            throttle = 1500
            base_motor = throttle
            m0 = base_motor + p_roll * 0.5 + p_pitch * 0.5
            m1 = base_motor - p_roll * 0.5 + p_pitch * 0.5
            m2 = base_motor + p_roll * 0.5 - p_pitch * 0.5
            m3 = base_motor - p_roll * 0.5 - p_pitch * 0.5

            # Motor spread (imbalance)
            if motor_spread > 0:
                m0 *= (1 + motor_spread * 0.5)
                m2 *= (1 - motor_spread * 0.3)

            # Clamp motors
            m0 = max(1000, min(2000, m0))
            m1 = max(1000, min(2000, m1))
            m2 = max(1000, min(2000, m2))
            m3 = max(1000, min(2000, m3))

            writer.writerow([
                i, t_us,
                f"{p_roll:.1f}", f"{p_pitch:.1f}", f"{p_yaw:.1f}",
                f"{i_roll:.1f}", f"{i_pitch:.1f}", f"{i_yaw:.1f}",
                f"{d_roll:.1f}", f"{d_pitch:.1f}", f"{d_yaw:.1f}",
                f"{sp_roll:.1f}", f"{sp_pitch:.1f}", f"{sp_yaw:.1f}",
                f"{gy_roll:.1f}", f"{gy_pitch:.1f}", f"{gy_yaw:.1f}",
                f"{m0:.0f}", f"{m1:.0f}", f"{m2:.0f}", f"{m3:.0f}",
                f"{throttle}",
            ])


def main():
    os.makedirs(FIXTURES_DIR, exist_ok=True)

    # 1. Clean hover flight — minimal noise, good tuning
    generate_flight_csv(
        os.path.join(FIXTURES_DIR, "clean_hover.csv"),
        n_frames=4000, sample_rate_hz=500,
        noise_freqs=[], noise_amps=[],
        overshoot_pct=5.0, tracking_delay_ms=5.0,
    )
    print("  Generated: clean_hover.csv")

    # 2. Noisy flight — motor noise at 160Hz + structural at 85Hz
    generate_flight_csv(
        os.path.join(FIXTURES_DIR, "noisy_motors.csv"),
        n_frames=4000, sample_rate_hz=500,
        noise_freqs=[160.0, 85.0],
        noise_amps=[15.0, 8.0],
        overshoot_pct=15.0, tracking_delay_ms=12.0,
        motor_spread=0.1,
    )
    print("  Generated: noisy_motors.csv")

    # 3. Over-tuned flight — high overshoot, aggressive PIDs
    generate_flight_csv(
        os.path.join(FIXTURES_DIR, "over_tuned.csv"),
        n_frames=4000, sample_rate_hz=500,
        noise_freqs=[220.0],
        noise_amps=[20.0],
        overshoot_pct=35.0, tracking_delay_ms=3.0,
    )
    print("  Generated: over_tuned.csv")

    # 4. Under-tuned flight — high delay, sluggish response
    generate_flight_csv(
        os.path.join(FIXTURES_DIR, "under_tuned.csv"),
        n_frames=4000, sample_rate_hz=500,
        noise_freqs=[],
        noise_amps=[],
        overshoot_pct=2.0, tracking_delay_ms=30.0,
    )
    print("  Generated: under_tuned.csv")

    # 5. Short flight — edge case, minimum viable data
    generate_flight_csv(
        os.path.join(FIXTURES_DIR, "short_flight.csv"),
        n_frames=600, sample_rate_hz=500,
        noise_freqs=[],
        noise_amps=[],
    )
    print("  Generated: short_flight.csv")

    print(f"\n  All fixtures generated in {FIXTURES_DIR}/")


if __name__ == "__main__":
    main()
